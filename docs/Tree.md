##5. Дерево (Tree)

###5.1 Структура дерева

Дерево &mdash; [структура данных][1], эмулирующая древовидную структуру в виде набора связанных узлов.

```
           ┌─────┐
           |     |           Корневой узел
           └─────┘
         /    |    \
  ┌─────┐  ┌─────┐  ┌─────┐
  |     |  |     |  |     |   Дочерние узлы
  └─────┘  └─────┘  └─────┘
         /    |    \
  ┌─────┐  ┌─────┐  ┌─────┐
  |     |  |     |  |     |   Дочерние узлы дочерних узлов
  └─────┘  └─────┘  └─────┘
```

Пример &mdash; синтаксическое дерево для выражения `2 * sin(3 * z - 7)`

```
          ┌─────┐
          |  *  |
          └─────┘
         /       \
   ┌─────┐        ┌─────┐
   |  2  |        | sin |
   └─────┘        └─────┘
                     |
                  ┌─────┐
                  |  -  |
                  └─────┘
                 /       \
           ┌─────┐       ┌─────┐
           |  *  |       |  7  |
           └─────┘       └─────┘
          /       \
    ┌─────┐       ┌─────┐
    |  3  |       |  z  |
    └─────┘       └─────┘
```

[1]: https://ru.wikipedia.org/wiki/Дерево_(структура_данных)

Еще один пример &mdash; двоичное дерево поиска. Термин &laquo;двоичное&raquo; означет, что у каждого из узлов есть
не более двух дочерних узлов. &laquo;Дерево поиска&raquo; означает, что все значения в левом поддереве каждого узла
меньше или равны значению этого узла, а все значения в правом поддереве &mdash; наоборот &mdash; больше.

```
          ┌─────┐
          |  0  |   <- 0 больше -1, но меньше любого из [1, 5, 7, 8, 9]
          └─────┘
         /       \
   ┌─────┐        ┌─────┐
   | -1  |        |  8  |   <- 8 больше любого из [1, 5, 7], но меньше 9
   └─────┘        └─────┘
                 /       \
           ┌─────┐       ┌─────┐
           |  5  |       |  9  |
           └─────┘       └─────┘
          /       \
    ┌─────┐       ┌─────┐
    |  1  |       |  7  |
    └─────┘       └─────┘
```

Если в таком дереве нам надо найти значение 7, то нам нужно совершить такие действия:

1. Зайти в узел 0. Искомое 7 больше 0, значит нужно продолжить итерирование вправо;
2. Зайти в узел 8. Искомое 7 меньше 8, значит нужно продолжить итерирование влево;
3. Зайти в узел 5. Искомое 7 больше 5, значит нужно продолжить итерирование вправо;
4. Зайти в узел 7. Это и есть искомое значение, можно закончить итерирование.

###5.2 Операции над деревом

####5.2.1 Вычисление высоты дерева (height)

```js
function height(tree) {
    // Если дерево пусто, то его высота равна нулю
    if (!tree) {
        return 0;
    }

    // Иначе высота равна единице плюс максимальная высота из высот левого и правого поддеревьев
    return 1 + Math.max(height(tree.left), height(tree.right));
}
```

####5.2.2 Вычисление размера дерева

```js
function size(tree) {
    // Если дерево пусто, то его размер равен нулю
    if (!tree) {
        return 0;
    }

    // Иначе размер равен сумме единицы и размеров левого и правого поддеревьев
    return 1 + size(tree.left) + size(tree.right);
}
```

###5.3 Обход дерева

Часто возникает задача обхода всех узлов дерева в определенном порядке. Существует два основных способа обхода
деревьев:

1. _Обход в глубину (depth-first)_ &mdash; обход всего поддерева прежде, чем переход к следущему одноуровневому (sibling)
поддереву;
1. _Обход в ширину (breadth-first)_ &mdash; обход всего уровня прежде, чем переход к следущему уровню.

####5.3.1 Симметричный обход (in-order traversal)

Это обход бинарного дерева в глубину, при котором сначала обходится левое поддерево, затем сам текущий узел, а после этого
&mdash; правое поддерево.

```js
function inOrderTraversal(tree) {
    // Если дерево пусто, то нужно остановить обход
    if (!tree) {
        return;
    }

    // Обходим сначала левое поддерево
    inOrderTraversal(tree.left);

    // Выводим значение в текущем узле
    console.log(tree.key);

    // Затем обходим правое поддерево
    inOrderTraversal(tree.right);
}
```

Например, если у нас есть такое двоичное дерево поиска:

```js
const tree = {
    key: 0,
    left: {key: -1},
    right: {
        key: 8,
        left: {
            key: 5,
            left: {key: 1},
            right: {key: 7}
        },
        right: {key: 9}
    }
};
```

То при симметричном обходе мы получим вывод узлов в порядке возрастания.

```js
inOrderTraversal(tree); // -1, 0, 1, 5, 7, 8, 9
```
