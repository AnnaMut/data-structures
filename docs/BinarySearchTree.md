##6. Двоичное дерево поиска (Binary search tree)

Прежде чем перейти к двоичному дереву поиска, вспомним что такое двоичный поиск по отсортированному массиву (он же _метод деления пополам_ или _дихотомия_).

###6.2 Двоичный поиск

Искать элементы в отсортированном массиве можно гораздо быстрее, чем в неотсортированном.

```
    ┌────┬────┬────┬────┬────┬────┬────┬────┬────┐
    |  0 |  1 |  3 | 10 | 11 | 23 | 30 | 71 | 99 |
    └────┴────┴────┴────┴────┴────┴────┴────┴────┘
```

Если нам нужно найти число 30 в отсортированном массиве, мы можем сделать такие итерации:

1. Начать итерирование с середины массива &mdash; число 11. Число 30 больше числа 11, значит мы можем отбросить
в наших поисках все значения с начала массива по элемент со
значением 11 включительно;
1. Затем мы снова поделим оставшийся массив пополам, взяв элемент 71. 30 меньше 71, значит мы можем отбросить все
элементы правее 71 включительно;
1. Продолжим деление пополам, взяв элемент со значением 30. Это и есть искомый элемент &mdash; можно заканчивать
итерирование

```
                           |
                           v
    ┌────┬────┬────┬────┬────┬────┬────┬────┬────┐
1.  |    |    |    |    |    | 23 | 30 | 71 | 99 |
    └────┴────┴────┴────┴────┴────┴────┴────┴────┘

                                          |
                                          v
    ┌────┬────┬────┬────┬────┬────┬────┬────┬────┐
2.  |    |    |    |    |    | 23 | 30 |    |    |
    └────┴────┴────┴────┴────┴────┴────┴────┴────┘

                                     |
                                     v
    ┌────┬────┬────┬────┬────┬────┬────┬────┬────┐
3.  |    |    |    |    |    |    | 30 |    |    |
    └────┴────┴────┴────┴────┴────┴────┴────┴────┘
```

Каждая итерация в двоичном поиске исключает из массива половину элементов. Это происходит из-за того, что массив
отсортирован. Во время поиска мы можем точно определить, какую из половин массива нам следует исключить из дальнейших
итераций, благодаря сравнению текущего элемента с искомым. Двоичный поиск работает за _O(log n)_, в отличие
от линейного поиска, который работает за _O(n)_.

Отсортированный массив прекрасно подходит для поиска элементов, но плохо подходит для добавления и удаления
элементов (оба работают за _O(n)_ по времени). Двоичное дерево поиска может обеспечивать такую же сложность поиска,
но быть гораздо эффективнее массива при добавлении и удалении элементов.

###6.3 Структура двоичного дерева поиска

Главная идея, которая лежит в основе двоичного дерева поиска, &mdash; взять все элементы отсортированного массива
и организовать их в виде двоичного дерева.

```
    ┌────┬────┬────┬────┬────┬────┬────┬────┬────┐
    |  0 |  1 |  3 | 10 | 11 | 23 | 30 | 71 | 99 |
    └────┴────┴────┴────┴────┴────┴────┴────┴────┘

                           |
                           v

                        ┌─────┐
                        |  11 |
                        └─────┘
                       /       \
                 ┌─────┐        ┌─────┐
                 |  3  |        |  30 |
                 └─────┘        └─────┘
                /      |        |      \
            ┌─────┐  ┌─────┐ ┌─────┐  ┌─────┐
            |  1  |  |  10 | |  23 |  |  71 |
            └─────┘  └─────┘ └─────┘  └─────┘
            /                               \
        ┌─────┐                            ┌─────┐
        |  0  |                            |  99 |
        └─────┘                            └─────┘
```

Двоичное дерево поиска должно обладать такими свойствами:

1. Каждый узел должен иметь не более двух поддеревьев (это должно быть двоичное дерево);
2. Каждый узел в дереве должен быть больше всех узлов в своем левом поддереве;
2. Каждый узел в дереве должен быть меньше всех узлов в своем правом поддереве.
