#Структуры данных

##TOC

##Связанные списки

Они же Linked Lists.

###Структура

```
+------+
| key  | ключ
+------+
| next | указатель на следующий элемент
+------+

HEAD
  |
  v
+---+       +---+       +---+
| 1 |  +--> | 2 |  +--> | 3 |
+---+  |    +---+  |    +---+
| -----+    | -----+    |   |
+---+       +---+       +---+
```

###Операции над связанными списками

1. Добавление в начало `pushFront(key)`
1. Возврат первого элемента `key topFront()`
1. Удаление первого элемента `popFront()`
1. Добавление в конец `pushBack(key)/append`
1. Возврат последнего элемента `key topBack()`
1. Удаление последнего элемента `popBack()`
1. Поиск элемента в списке `boolean find(key)`
1. Удаление элемента по значению `erase(key)`
1. Проверка на пустоту `boolean empty()`
1. Получение длины списка `size()`
1. Добавление по индексу `insert(index, key)`

###Времена некоторых операций

####pushFront(key)

1. Создание элемента &mdash; O(1)
1. Сохранение во вновь созданнный элемент ссылки на текущий HEAD &mdash; O(1)
1. Запись в HEAD ссылки на новый элемент &mdash; O(1)

####key topFront()

1. Возвращение HEAD &mdash; O(1)

####popFront()

1. Обновление HEAD на next у HEAD &mdash; O(1)
1. Удаление бывшего HEAD &mdash; O(1)

####pushBack(key)/append

Если нет указателя на последний элемент

1. Нужно сделать N-1 итераций, чтобы найти предпоследний элемент &mdash; O(n)
1. Обнулить указатель next у предпоследнего элемента &mdash; O(1)
1. Удалить последний элемент &mdash; O(1)

Если есть указатель на последний элемент

1. Создание нового элемента &mdash; O(1)
1. Обновление next у TAIL на вновь созданный элемент &mdash; O(1)
1. Обновление TAIL &mdash; O(1)

####key topBack()

1. Вернуть TAIL &mdash; O(1)

####popBack()

1. Сделать N-1 итераций до предпоследнего элемента
1. Обнулить next у предпоследнего элемента
1. Освободить память от элемента, на который ссылается TAIL
1. Обновить TAIL на предпоследний элемент

###Реализация связанного списка

```
#include(LinkedList);
```
