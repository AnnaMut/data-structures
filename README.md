#Структуры данных

##TOC

##Связанные списки

Они же Linked Lists.

###Структура

```
+------+
| key  | ключ
+------+
| next | указатель на следующий элемент
+------+

HEAD
  |
  v
+---+       +---+       +---+
| 1 |  +--> | 2 |  +--> | 3 |
+---+  |    +---+  |    +---+
| -----+    | -----+    |   |
+---+       +---+       +---+
```

###Операции над связанными списками

1. Добавление в начало `PushFront(Key)`
1. Возврат первого элемента `Key TopFront()`
1. Удаление первого элемента `PopFront()`
1. Добавление в конец `PushBack(Key)/Append`
1. Возврат последнего элемента `Key TopBack()`
1. Удаление последнего элемента `PopBack()`
1. Поиск элемента в списке `Boolean Find(Key)`
1. Удаление элемента по значению `Erase(Key)`
1. Проверка на пустоту `Boolean Empty()`
1. Добавление перед элементом `AddBefore(Node, Key)`
1. Добавление после элемента `AddAfter(Node, Key)`

###Времена некоторых операций

####PushFront(Key)

1. Создание элемента &mdash; O(1)
1. Сохранение во вновь созданнный элемент ссылки на текущий HEAD &mdash; O(1)
1. Запись в HEAD ссылки на новый элемент &mdash; O(1)

####Key TopFront()

1. Возвращение HEAD &mdash; O(1)

####PopFront()

1. Обновление HEAD на next у HEAD &mdash; O(1)
1. Удаление бывшего HEAD &mdash; O(1)

####PushBack(Key)/Append

Если нет указателя на последний элемент

1. Нужно сделать N-1 итераций, чтобы найти предпоследний элемент &mdash; O(n)
1. Обнулить указатель next у предпоследнего элемента &mdash; O(1)
1. Удалить последний элемент &mdash; O(1)

Если есть указатель на последний элемент

1. Создание нового элемента &mdash; O(1)
1. Обновление next у TAIL на вновь созданный элемент &mdash; O(1)
1. Обновление TAIL &mdash; O(1)

####Key TopBack()

1. Вернуть TAIL &mdash; O(1)

####PopBack()

1. Сделать N-1 итераций до предпоследнего элемента
1. Обнулить next у предпоследнего элемента
1. Освободить память от элемента, на который ссылается TAIL
1. Обновить TAIL на предпоследний элемент

###Реализация связанного списка

```
#include(LinkedList);
```
